include "global.tbh"
'====================================================================
const ICSP_INIT_SIGNATURE=&hDDCA
const ICSP_STAMP="ICSP> "
const ICSP_CR_LF=chr(13)+chr(10)

const USER_ID="00112233445566"  'not ready

enum hex_record_type
	RECORD_DATA=&h00,
	RECORD_END_OF_LINE=&h01,
	RECORD_EXTENDED_SEGMENT_ADDR_REC=&h02
	RECORD_START_SEGMENT_ADDR_REC=&h03
	RECORD_EXTENDED_LINEAR_ADDR_REC=&h04
	RECORD_START_LINEAR_ADDRESS_REC=&h05
	RECORD_UNKNOWN=&hFF
end enum

enum icsp_cmd
	cmd_load_config
	cmd_load_prg_mem
	cmd_load_dat_mem
	cmd_read_prg_mem
	cmd_read_dat_mem
	cmd_increment_addr
	cmd_reset_addr
	cmd_begin_inter_prg
	cmd_begin_ext_prg
	cmd_end_ext_prg
	cmd_bulk_ers_prg_mem
	cmd_bulk_ers_dat_mem
	cmd_row_ers_prg_mem
	cmd_unkown
end enum

#if ICSP_DEBUG_PRINT=1
	declare sub icsp_debug_print(data as string)
#endif

declare sub io_control(pin as pl_io_num,state as low_high)

declare sub enter_lvp_mode()
declare sub leave_lvp_mode()

declare sub icsp_entry_write(data as byte)
declare function icsp_normal_read()as word
declare function icsp_program_read()as string

declare sub icsp_cmd_send(cmd as icsp_cmd)
declare sub icsp_program_send(data as string)
declare sub icsp_delay_in_ms(value as word)

declare sub icsp_configure_init()

declare function test()as ok_ng
dim dev_id as string
dim icsp_init_flag as word

sub icsp_cmd_send(cmd as icsp_cmd)
	dim value,base,x as byte

	select case cmd 
	case cmd_load_config:
		value=&h00

	case cmd_load_prg_mem:
		value=&h02

	case cmd_load_dat_mem:
		value=&h03

	case cmd_read_prg_mem:
		value=&h04

	case cmd_read_dat_mem:
		value=&h05

	case cmd_increment_addr:
		value=&h06

	case cmd_reset_addr:
		value=&h16

	case cmd_begin_inter_prg:
		value=&h08

	case cmd_begin_ext_prg:
		value=&h18

	case cmd_end_ext_prg:
		value=&h0A

	case cmd_bulk_ers_prg_mem:
		value=&h09

	case cmd_bulk_ers_dat_mem:
		value=&h0B

	case cmd_row_ers_prg_mem:
		value=&h11

	case cmd_unkown:
		value=&h0E
	end select

	base=&h01

	for x=0 to 5
		if value and base then
			io_control(ICSPCLK,LOW)
			io_control(ICSPDAT,HIGH)
			io_control(ICSPCLK,HIGH)
		else
			io_control(ICSPCLK,LOW)
			io_control(ICSPDAT,LOW)
			io_control(ICSPCLK,HIGH)
		end if
		base=base*2
	next x

	io_control(ICSPCLK,LOW)

	select case cmd
	case cmd_read_prg_mem,cmd_read_dat_mem:
		io.num=ICSPDAT
		io.enabled=NO	
	end select
end sub

sub icsp_program_send(data as string)
	'digit order :2->1 -> 4->3
	dim value1,value2,value3,value4,base,x as byte
	dim s as string(1)

	s=mid(data,1,1)
	value1=val("&h"+s)

	s=mid(data,2,1)
	value2=val("&h"+s)

	s=mid(data,3,1)
	value3=val("&h"+s)

	s=mid(data,4,1)
	value4=val("&h"+s)

	icsp_cmd_send(cmd_load_prg_mem)

	'Start Bit
	io_control(ICSPDAT,LOW)
	io_control(ICSPCLK,HIGH)
	io_control(ICSPCLK,LOW)

	base=&h01
	for x=0 to 3
		if value2 and base then
			io_control(ICSPDAT,HIGH)
		else
			io_control(ICSPDAT,LOW)
		end if
		io_control(ICSPCLK,HIGH)
		io_control(ICSPCLK,LOW)
		base=base*2
	next x

	base=&h01
	for x=0 to 3
		if value1 and base then
			io_control(ICSPDAT,HIGH)
		else
			io_control(ICSPDAT,LOW)
		end if
		io_control(ICSPCLK,HIGH)
		io_control(ICSPCLK,LOW)
		base=base*2
	next x

	base=&h01
	for x=0 to 3
		if value4 and base then
			io_control(ICSPDAT,HIGH)
		else
			io_control(ICSPDAT,LOW)
		end if
		io_control(ICSPCLK,HIGH)
		io_control(ICSPCLK,LOW)
		base=base*2
	next x

	base=&h01
	for x=0 to 1
		if value3 and base then
			io_control(ICSPDAT,HIGH)
		else
			io_control(ICSPDAT,LOW)
		end if
		io_control(ICSPCLK,HIGH)
		io_control(ICSPCLK,LOW)
		base=base*2
	next x

	'Stop Bit
	io_control(ICSPDAT,LOW)
	io_control(ICSPCLK,HIGH)
	io_control(ICSPCLK,LOW)
end sub

sub icsp_init()
	icsp_init_flag=ICSP_INIT_SIGNATURE
end sub

sub io_control(pin as pl_io_num,state as low_high)
	io.num=pin
	if state=HIGH  then
		io.lineset(pin,HIGH)
		io.enabled=YES
		io.enabled=NO
	else
		io.enabled=YES
		io.lineset(pin,LOW)
	end if
end sub

sub icsp_entry_write(data as byte)
	dim bitCnt as byte
	dim compval as byte
	dim BitData as boolean
	dim flag as no_yes=NO

	compval = &h80
	io_control(ICSPCLK,LOW)
	for bitCnt = 0 to 7 step 1	
		BitData = data AND compval
		compval = compval / 2

		if(BitData) then 
			if flag=NO then
				io_control(ICSPDAT,HIGH)				'Bit is 1
				flag=YES
			else
				flag=YES
			end if
		else
			io_control(ICSPDAT,LOW)					'Bit is 0
			flag=NO
		end if

		io_control(ICSPCLK,HIGH)
		io_control(ICSPCLK,LOW)
	next bitCnt
end sub

sub enter_lvp_mode()
	#if ICSP_DEBUG_PRINT=1
		icsp_debug_print("Enter Low Voltage Programing Mode")
	#endif	
	'Enter Programming Mode
	io_control(ICSPCLK,LOW)
	io_control(ICSPDAT,LOW)
	io_control(MCLR,LOW)

	icsp_delay_in_ms(10)
	io_control(MCLR,HIGH)
	icsp_delay_in_ms(10)
	io_control(MCLR,LOW)
	icsp_delay_in_ms(2)
 
	'Send ASCII (MCLR) 
	icsp_entry_write(&b00001010)
	icsp_entry_write(&b00010010)
	icsp_entry_write(&b11000010)
	icsp_entry_write(&b10110010)
	io_control(ICSPCLK,HIGH)
	io_control(ICSPCLK,LOW)
	icsp_delay_in_ms(20)	
end sub

sub leave_lvp_mode()
	'Leave Programming Mode
	io_control(ICSPCLK,HIGH)
	io_control(ICSPDAT,HIGH)
	icsp_delay_in_ms(1)
	io_control(MCLR,HIGH)
	icsp_delay_in_ms(5)
	#if ICSP_DEBUG_PRINT=1
		icsp_debug_print("Leave Low Voltage Programing Mode")
	#endif	
end sub

function icsp_normal_read()as word
	dim x as byte
	dim tmp as word
	dim bitCmp as word

	icsp_normal_read=""
	bitCmp=2
	tmp=0
	'start bit
	io_control(ICSPCLK,LOW)
	io_control(ICSPDAT,LOW)
	io_control(ICSPCLK,HIGH)
	io_control(ICSPCLK,LOW)

	io.num=ICSPDAT
	io.enabled=NO

	'lsb  8 bit
	for x=0 to 13
		io_control(ICSPCLK,HIGH)
		if io.lineget(ICSPDAT)=HIGH then
			tmp=tmp or bitCmp
		end if
		io_control(ICSPCLK,LOW)
		bitCmp=bitCmp*2
	next x

	'stop bit
	io_control(ICSPCLK,LOW)
	io_control(ICSPDAT,LOW)
	io_control(ICSPCLK,HIGH)
	io_control(ICSPCLK,LOW)

	icsp_normal_read=tmp
end function

function icsp_program_read()as string
	dim value1,value2,value3,value4 as byte
	dim x,bitCmp as byte

	icsp_program_read=""

	icsp_cmd_send(cmd_read_prg_mem)

	value1=0
	value2=0
	value3=0
	value4=0

	'start bit
	io_control(ICSPCLK,LOW)
	io_control(ICSPDAT,LOW)
	io_control(ICSPCLK,HIGH)
	io_control(ICSPCLK,LOW)

	io.num=ICSPDAT
	io.enabled=NO

	bitCmp=1
	for x=0 to 3
		io_control(ICSPCLK,HIGH)
		io_control(ICSPCLK,LOW)
		if io.lineget(ICSPDAT)=HIGH then
			value1=value1 or bitCmp
		end if
		bitCmp=bitCmp*2
	next x

	bitCmp=1
	for x=0 to 3
		io_control(ICSPCLK,HIGH)
		io_control(ICSPCLK,LOW)
		if io.lineget(ICSPDAT)=HIGH then
			value2=value2 or bitCmp
		end if
		bitCmp=bitCmp*2
	next x

	bitCmp=1
	for x=0 to 3
		io_control(ICSPCLK,HIGH)
		io_control(ICSPCLK,LOW)
		if io.lineget(ICSPDAT)=HIGH then
			value3=value3 or bitCmp
		end if
		bitCmp=bitCmp*2
	next x

	bitCmp=1
	for x=0 to 1
		io_control(ICSPCLK,HIGH)
		io_control(ICSPCLK,LOW)
		if io.lineget(ICSPDAT)=HIGH then
			value4=value4 or bitCmp
		end if
		bitCmp=bitCmp*2
	next x

	'stop bit
	io_control(ICSPCLK,LOW)
	io_control(ICSPDAT,LOW)
	io_control(ICSPCLK,HIGH)
	io_control(ICSPCLK,LOW)

	dim tmp as word
	dim result as string
	tmp=value2*4096+value1*256+value4*16+value3
	result=mid(hex(tmp),3,4)
	
	if len(result)<4 then
		result=strgen(4-len(result),"0")+result
	end if
	icsp_program_read=result

	icsp_cmd_send(cmd_increment_addr)
end function

function iscp_download_hex()as icsp_status
	dim tmr,tmp as word
	dim addr,lastcount,lastaddr,pcaddr as word
	dim recType,lastType as hex_record_type
	dim byteCount,fchecksum,sendCount,pending as byte
	dim buff as string
	dim s,ss as string
	dim datadone as no_yes

	datadone=NO
	iscp_download_hex=IS_UPLOAD_UNKNOWN

	romfile.open(FW_FILE)
	romfile.pointer=1
	if romfile.size=0 then
		#if ICSP_DEBUG_PRINT=1
			icsp_debug_print("CANNOT FOUND THE FW")
		#endif
		iscp_download_hex=IS_CANNOT_FOUND_FW_FILE
		goto leave
	end if

	icsp_configure_init()

	enter_lvp_mode()

	icsp_cmd_send(cmd_load_config)
	tmp=icsp_normal_read()

	'USER ID
	for tmr =0 to 5
		icsp_cmd_send(cmd_increment_addr)
	next tmr

	'Device ID
	dev_id=icsp_program_read()

	'Cofigure 1
	s=icsp_program_read()

	'Configure 2
	ss=icsp_program_read()

	dim id,rev as word
	id= val("&h"+dev_id)
	id= id  and &hF03F
	rev=val("&h"+dev_id)
	if rev and &h1000 then
		rev=16
	else
		rev=0
	end if
	
	rev=rev+val(mid(dev_id,2,1))
	#if ICSP_DEBUG_PRINT=1
		icsp_debug_print("ID/Rev. :"+hex(id)+"/"+hex(rev))
	#endif

	if id<>&h4027 then
		#if ICSP_DEBUG_PRINT=1
			icsp_debug_print("dev id incoreect !")
		#endif
		iscp_download_hex=IS_DEV_ID_ERR
		goto leave
	end if

	leave_lvp_mode()

	icsp_delay_in_ms(10)
	enter_lvp_mode()
	icsp_delay_in_ms(10)
	icsp_program_send("FF3F")
	pcaddr=0
	lastaddr=0
	lastcount=0
	lastType=RECORD_UNKNOWN
	while 1
		header_extract:
		while 1
			s=romfile.getdata(1)
			if s=":" then
				byteCount=val("&h"+romfile.getdata(2))
				addr=val("&h"+romfile.getdata(4))
				recType=val(romfile.getdata(2))
				buff=romfile.getdata(byteCount*2)
				fchecksum=romfile.getdata(2)
				if byteCount mod 2 <>0 then
					#if ICSP_DEBUG_PRINT=1
						icsp_debug_print("FORMAT ERR")
					#endif
					iscp_download_hex=IS_FW_FILE_FORMAT_ERR
					goto leave
				end if
				exit while
			end if
		wend

		select case recType
		case RECORD_DATA:
			if datadone=YES then  'Configuration Bit
				icsp_program_send(buff)
				icsp_cmd_send(cmd_begin_inter_prg)
				icsp_delay_in_ms(3)
				icsp_cmd_send(cmd_increment_addr)
				goto header_extract
			end if

			while lastcount+lastaddr<addr
				icsp_program_send("FF3F")
				icsp_cmd_send(cmd_increment_addr)
				pcaddr=pcaddr+1
				lastcount=lastcount+2
			wend

			s=mid(buff,1,4)
			for sendCount= 5 to (byteCount+1)*2 step 4
				icsp_program_send(s)
				pcaddr=pcaddr+1
				if pcaddr mod 32 =0 then
					'allow to write the program words
					icsp_cmd_send(cmd_begin_inter_prg)
					icsp_delay_in_ms(3)
				end if
				icsp_cmd_send(cmd_increment_addr)
				s=mid(buff,sendCount,4)
			next sendCount
			lastaddr=addr
			lastcount=byteCount
			lastType=recType

		case RECORD_EXTENDED_LINEAR_ADDR_REC:
			if buff="0001" and lastType=RECORD_DATA then
				while  pcaddr mod 32<>0
					icsp_program_send("FF3F")
					if pcaddr mod 31=0 then
						icsp_cmd_send(cmd_begin_inter_prg)
						icsp_delay_in_ms(3)
						exit while
					end if
					pcaddr=pcaddr+1
					icsp_cmd_send(cmd_increment_addr)
				wend

				leave_lvp_mode()
				icsp_delay_in_ms(10)
				enter_lvp_mode()
				icsp_cmd_send(cmd_load_config)
				tmp=icsp_normal_read()

				'USER ID
				s=mid(USER_ID,1,4)
				icsp_program_send(s)
				icsp_cmd_send(cmd_begin_inter_prg)
				icsp_delay_in_ms(3)
				icsp_cmd_send(cmd_increment_addr)


				s=mid(USER_ID,5,4)
				icsp_program_send(s)
				icsp_cmd_send(cmd_begin_inter_prg)
				icsp_delay_in_ms(3)
				icsp_cmd_send(cmd_increment_addr)

				s=mid(USER_ID,9,4)
				icsp_program_send(s)
				icsp_cmd_send(cmd_begin_inter_prg)
				icsp_delay_in_ms(3)
				icsp_cmd_send(cmd_increment_addr)

				s=mid(USER_ID,13,4)
				icsp_program_send(s)
				icsp_cmd_send(cmd_begin_inter_prg)
				icsp_delay_in_ms(3)
				icsp_cmd_send(cmd_increment_addr)


				icsp_cmd_send(cmd_increment_addr)
				icsp_cmd_send(cmd_increment_addr)

				'Device ID
				icsp_program_send(dev_id)
				icsp_cmd_send(cmd_increment_addr)

				datadone=YES
			end if

		case RECORD_END_OF_LINE:
			exit while

		end select
		goto header_extract
	wend

	#if ICSP_DEBUG_PRINT=1
		icsp_debug_print("Verify Program Memory")
	#endif

	pcaddr=0
	icsp_cmd_send(cmd_reset_addr)
	romfile.pointer=1
	while 1
		header_extract2:
		while 1
			s=romfile.getdata(1)
			if s=":" then
				tmp=val(romfile.getdata(1))
				if tmp=1 then
					byteCount=16
				else
					byteCount=0
				end if
				tmp=val(romfile.getdata(1))
				byteCount=byteCount+tmp
				addr=val(romfile.getdata(4))
				recType=val(romfile.getdata(2))
				buff=romfile.getdata(byteCount*2)
				fchecksum=romfile.getdata(2)
				exit while
			end if
		wend

		select case recType
		case RECORD_DATA:
			for sendCount= 1 to byteCount*2 step 4
				s=mid(buff,sendCount,4)
				ss=icsp_program_read()
				pcaddr=pcaddr+1
				#if ICSP_DEBUG_PRINT=1
					icsp_debug_print(ss)
				#endif
				if ss<>s then
					#if ICSP_DEBUG_PRINT=1
						icsp_debug_print("DATA CHECK ERR.")
					#endif
					iscp_download_hex=IS_DATA_CHECK_ERR
					goto leave
				end if
			next sendCount

			'alignment check
			if byteCount mod 4 <> 0 then
				pending=pcaddr mod 4
				while pending >0
					pending=pending/8
					ss=icsp_program_read()
					pcaddr=pcaddr+1
					if ss<>"FF3F" then
						#if ICSP_DEBUG_PRINT=1
							icsp_debug_print("DATA CHECK ERR.")
						#endif
						iscp_download_hex=IS_DATA_CHECK_ERR
						goto leave
					end if
				wend
			end if

		case RECORD_EXTENDED_LINEAR_ADDR_REC:
			if buff="0001" then
				'now, we skip the configuration word's check
				iscp_download_hex=IS_UPLOAD_OK
				exit while
			end if
		
		case RECORD_END_OF_LINE:
			iscp_download_hex=IS_UPLOAD_OK
			#if ICSP_DEBUG_PRINT=1
				icsp_debug_print("pcaddr:"+hex(pcaddr))
			#endif
			iscp_download_hex=IS_UPLOAD_OK
			exit while

		end select
		goto header_extract2
	wend

leave:
	leave_lvp_mode()
	
	test()
end function

sub icsp_configure_init()
	dim tmp as word
	enter_lvp_mode()

	icsp_cmd_send(cmd_load_config)
	tmp=icsp_normal_read()

	icsp_cmd_send(cmd_bulk_ers_prg_mem)
	icsp_delay_in_ms(20)

	for tmp=0 to 6
		icsp_cmd_send(cmd_increment_addr)
	next tmp

	'now, pc address=8007h

	icsp_program_send("E409")
	icsp_cmd_send(cmd_begin_inter_prg)
	icsp_delay_in_ms(5)

	icsp_cmd_send(cmd_increment_addr)

	icsp_program_send("FF3D")
	icsp_cmd_send(cmd_begin_inter_prg)
	icsp_delay_in_ms(5)

	leave_lvp_mode()
end sub

sub icsp_delay_in_ms(value as word)
	dim ax,bx as word

	for ax=0 to value
		for bx=0 to 5
		next bx
	next ax
end sub

function test()as ok_ng
	dim tmp as string
	dim i2cnum as byte
	test=OK

	i2cnum=si2c_register("ICSP",ICSPDAT,ICSPCLK,LOW)
	si2c_get(i2cnum)

	pic_reg_write(TRISC,chr(&h2f))
	tmp=pic_reg_read(TRISC,1)

	icsp_delay_in_ms(10)
	
	pic_reg_write(TRISC,chr(&h3f))
	tmp=pic_reg_read(TRISC,1)
	if tmp<>chr(&h3f) then
		test=NG
		goto leave_test
	end if

	pic_reg_write(TRISC,chr(&h2f))
	tmp=pic_reg_read(TRISC,1)
	if tmp<>chr(&h2f) then
		test=NG
		goto leave_test
	end if
leave_test:
	si2c_release(i2cnum)
end function

#if ICSP_DEBUG_PRINT=1
sub icsp_debug_print(data as string)
	sys.debugprint(ICSP_STAMP+data+ICSP_CR_LF)
end sub
#endif
